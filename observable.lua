--[[
    Lua Cold Observables
	
    MIT License
    Copyright (c) 2019 Alexis Munsayac
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
]]

local M = {}

local function isNumber(x)
    return type(x) == "number"
end

local function isTable(x)
    return type(x) == "table"
end 

local function isFunction(x)
    return type(x) == "function"
end

local function isObservable(x)
    return getmetatable(x) == M 
end

local function emptyHandler()
end

local function new(_, subscriber)
    local observable = {}

    observable.subscriber = subscriber

    return setmetatable(observable, M)
end 

local function subscribe(observable, onNext, onError, onComplete)
    --[[
        Represents the availability of the subscription
    ]]
    local closeState = false
    --[[
        The attached subscriber handler
    ]]
    local subscriber = observable.subscriber
    --[[
        cleanup function 
    ]]
    local cleanup = emptyHandler
    --[[
        Check if the observable has a subscriber
    ]]
    if(subscriber) then 
        --[[
            Execute subscriber
        ]]
        local status, result = pcall(function ()
            return subscriber(
                --[[
                    Receives the emitted values
                ]]
                function (...)
                    if(not closeState) then 
                        if(isFunction(onNext)) then
                            onNext(...) 
                        end
                    end
                end,
                --[[
                    Receives the error
                ]]
                function (...)
                    if(not closeState) then 
                        closeState = true 
                        if(isFunction(onError)) then
                            onError(...)
                        end
                    end
                end,
                --[[
                    Receives the completion
                ]]
                function ()
                    if(not closeState) then 
                        closeState = true 
                        if(isFunction(onComplete)) then
                            onComplete()
                        end
                    end
                end,
                --[[
                    Defines if the subscription has been closed
                ]]
                function ()
                    return closeState
                end
            )
        end)
        --[[
            Get the cleanup function generated by the subscriber
        ]]
        if(status) then 
            cleanup = result 
        else 
            closeState = true
            onError(result)
        end
    end 

    return function ()
        if(not closeState) then 
            closeState = true 
            cleanup()
        end
    end
end 


--[[
    Creating Observables
]]

--[[
    From 

    Converts any table or Observables into an Observable
]]
local function from(object)
    if(isObservable(object)) then 
        return new(_, function (next, err, complete)
            local seq = 0
            subscribe(object, function (x)
                seq = seq + 1
                next(x, seq)
            end, err, complete)
        end)
    elseif(isTable(object)) then 
        return new(_, function (next, err, complete, closed)
            for k, v in ipairs(object) do 
                next(v, k)
                if(closed()) then 
                    return 
                end
            end 
            complete()
        end)
    end 
end 

--[[
    Of

    Converts the sequence of arguments into an Observable
]]
local function of(...)
    return from({...})
end


--[[
    Empty

    Returns a completed observable
]]
local function empty()
    return new(_, function (next, err, complete)
        complete()        
    end)
end 


--[[
    Never

    Returns an Observable that neither emits, throws errors or completes
]]
local function never()
    return new(_, function () end)
end 


--[[
    Throw 

    Returns an Observable that throws an error
]]
local function throw(throwable)
    return new(_, function (next, err, complete)
        err(throwable)
    end)
end 


--[[
    Just

    Returns an Observable that emits a single value and then completes
]]
local function just(value)
    return new(_, function (next, err, complete)
        next(value)
        complete()
    end)
end 

local abs = math.abs


--[[
    Range

    Turns a given range, regardless of the direction (whether descending
    or ascending) into an Observable
]]
local function range(s, e)
    assert(isNumber(s), "TypeError: s is not a number (s : "..s)
    assert(isNumber(e), "TypeError: e is not a number (e : "..e)
    local sgn = (e - s)/abs(e - s)
    return new(_, function (next, err, complete, closed)
        local seq = 0
        for i = s, e, sgn do 
            seq = seq + 1
            next(i, seq)

            if(closed()) then 
                return 
            end 
        end 
        complete()
    end)
end 
--[[
    doRepeat

    Returns an Observable that emits a value multiple times
]]
local function doRepeat(value, iterations)
    assert(isNumber(iterations), "TypeError: iterations is not a number (iterations : "..iterations)
    return new(_, function (next, err, complete, closed)
        local seq = 0
        for i = 1, iterations do
            seq = seq + 1 
            next(i, seq)

            if(closed()) then 
                return 
            end 
        end 
        complete()
    end)
end 


--[[
    doWhile

    Returns an Observable that doesn't stop until the passed handler returns false.
    If the Observable completes without the handler returning false, the Observable
    then re-emits the sequence of emissions
]]
local function doWhile(observable, handler)
    return new(_, function (next, err, complete, closed)
        local seq = seq + 1

        --[[
            A function that handles the subscription for the observable
        ]]
        local function resubscribe()
            subscribe(observable,
                function (x)
                    local status, result = pcall(function ()
                        return handler(x)
                    end)

                    if(status) then 
                        if(result) then 
                            seq = seq + 1
                            next(x, seq, observable)
                        else 
                            complete()
                        end 
                    else 
                        err(result)
                    end 
                end,
                err,
                resubscribe
            )
        end
        resubscribe()
    end)
end

--[[
    Transforming Observables
]]

--[[
    buffer

    Emits the previous sequences of emissions by buffers given that the
    current emission returns true if passed into the boundary criteria
]]
local function buffer(observable, boundary)
    return new(_, function (next, err, complete, closed)
        local acc = {}
        local seq = 0
        subscribe(observable,
            function (x)
                local status, result = pcall(function ()
                    return boundary(x)
                end)

                if(status) then 
                    acc[#acc + 1] = x
                    if(result) then 
                        seq = seq + 1
                        next(acc, seq, observable)
                        acc = {}
                    end 
                else 
                    err(result)
                end 
            end,
            err,
            function ()
                seq = seq + 1
                next(acc, seq, observable)

                complete()
            end
        )
    end)
end 

local function defaultFlatMapMutator(x)
    return just(x)
end


--[[
    flatMap

    Transforms every emission into an Observable and then 
    sequences those observables into a single Observable flows
]]
local function flatMap(observable, mutator)
    mutator = isFunction(mutator) and mutator or defaultFlatMapMutator
    return new(_, function (next, err, complete, closed)
        local seq = 0
        subscribe(observable,
            function (x)
                local status, result = pcall(function ()
                    return mutator(x)
                end)

                if(status) then 
                    if(isObservable(result)) then 
                        subscribe(result,
                            function (v)
                                seq = seq + 1
                                next(v, seq)
                            end,
                            err
                        )
                    else 
                        seq = seq + 1
                        next(result, seq)
                    end 
                else 
                    err(result)
                end
            end,
            err,
            complete
        )
    end)
end 

--[[
    flatMapLatest

    Like flatMap, except that if a new value is emitted from the observable,
    enters the mutator and returns an Observable, it completes the previously
    emitted Observable.
]]
local function flatMapLatest(observable, mutator)
    mutator = isFunction(mutator) and mutator or defaultFlatMapMutator
    return new(_, function (next, err, complete, closed)
        local lastSubscription
        local seq = 0
        subscribe(observable,
            function (x)
                local status, result = pcall(function ()
                    return mutator(x)
                end)

                if(status) then 
                    if(isObservable(result)) then 
                        if(lastSubscription) then 
                            lastSubscription()
                        end 
                        lastSubscription = subscribe(result,
                            function (v)
                                seq = seq + 1
                                next(v, seq)
                            end,
                            err
                        )
                    else 
                        seq = seq + 1
                        next(result, seq)
                    end 
                else 
                    err(result)
                end
            end,
            err,
            complete 
        )
    end)
end 

local function flatMapObserver(observable, onNext, onError, onComplete)
    onNext = isFunction(onNext) and onNext or defaultFlatMapMutator
    onError = isFunction(onError) and onError or defaultFlatMapMutator
    onComplete = isFunction(onComplete) and onComplete or defaultFlatMapMutator

    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            function (x)
                local status, result = pcall(function ()
                    return onNext(x)
                end)

                if(status) then 
                    if(isObservable(result)) then 
                        subscribe(observable,
                            function (v)
                                seq = seq + 1
                                next(v, seq)
                            end,
                            err
                        )
                    else 
                        seq = seq + 1
                        next(result, seq)
                    end 
                else 
                    err(result)
                end
            end,
            function (x)
                local status, result = pcall(function ()
                    return onError(x)
                end)

                if(status) then 
                    if(isObservable(result)) then 
                        subscribe(observable,
                            function (v)
                                seq = seq + 1
                                next(v, seq)
                            end,
                            err
                        )
                    else 
                        seq = seq + 1
                        next(result, seq)
                    end 
                else 
                    err(result)
                end
            end,
            function ()
                local status, result = pcall(function ()
                    return onComplete()
                end)

                if(status) then 
                    if(isObservable(result)) then 
                        subscribe(observable,
                            function (v)
                                seq = seq + 1
                                next(v, seq)
                            end,
                            err
                        )
                    else 
                        seq = seq + 1
                        next(result, seq)
                    end 
                else 
                    err(result)
                end
            end
        )
    end)
end 

local function concatMap(observable, mutator)
    mutator = isFunction(mutator) and mutator or defaultFlatMapMutator

    return new(_, function (next, err, complete, closed)
        local queue = {}

        local seq = 0

        local lastEmission = false

        local function enqueue(x)
            if(not queue.first) then 
                queue.first = x 
            else 
                queue[queue.last] = x 
            end 
            queue.last = x 
            queue[x] = nil 
        end 

        local function dequeue()
            queue.first = queue[queue.first]
        end 

        local function prepareSubscription(obs)
            if(ready) then 
                ready = false
                subscribe(obs,
                    function (x)
                        seq = seq + 1
                        next(x, seq)
                    end,
                    err,
                    function () 
                        if(queue.first) then 
                            prepareSubscription(queue.first)
                            dequeue()
                        elseif(lastEmission) then 
                            complete()
                        else
                            ready = true
                        end 
                    end 
                )
            else 
                enqueue(obs)
            end
        end



        subscribe(observable,
            function (x)
                local status, result = pcall(function ()
                    return mutator(x)
                end)

                if(status) then 
                    if(isObservable(result)) then 
                        prepareSubscription(result)
                    else 
                        seq = seq + 1
                        next(result, seq)
                    end
                else 
                    err(result)
                end 
            end,
            err,
            function ()
                lastEmission = true
            end
        )
    end)

end

local function map(observable, mutator)
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            function (x)
                local status, result = pcall(function ()
                    return mutator(x)
                end)

                if(status) then 
                    next(result)
                else 
                    err(result)
                end 
            end,
            err, 
            complete
        )
    end)
end 

local function pluck(observable, key)
    return map(observable, function (x)
        return x[key]
    end)
end 

local function scan(observable, handler, seed)
    return new(_, function (next, err, complete, closed)
        local acc = seed
        
        subscribe(observable,
            function (x)
                local status, result = pcall(function ()
                    return handler(acc, x)
                end)

                if(status) then 
                    acc = result 

                    next(acc)
                else 
                    err(result)
                end 
            end,
            err,
            complete
        )
    end)
end 


--[[
    Filtering Observables
]]

local function defaultComparator(x)
    return x 
end

local function distinct(observable, comparator)
    return new(_, function (next, err, complete, closed)
        local flag = {}

        comparator = comparator or defaultComparator
        subscribe(observable,
            function (x)
                local index = comparator(x)
                if(not flag[index]) then 
                    flag[index] = true 

                    next(x)
                end 
            end,
            err,
            complete
        )
    end)
end 

local function distinctUntilChanged(observable, comparator)
    return new(_, function (next, err, complete, closed)
        local previous = nil
        local first = true

        comparator = comparator or defaultComparator
        subscribe(observable,
            function (x)
                local index = comparator(x)
                if(previous ~= index and not first) then 
                    next(x)
                elseif(first) then
                    next(x)
                    first = false
                end 
                previous = index
            end,
            err,
            complete
        )
    end)
end

local function elementAt(observable, index)
    return new(_, function (next, err, complete, closed)
        local seq = 0
        subscribe(observable, 
            function (x)
                seq = seq + 1
                if(index == seq) then 
                    next(x)
                    complete()
                end 
            end,
            err,
            function ()
                if(seq < index) then 
                    err("Argument out of range")
                else 
                    complete()
                end 
            end 
        )
    end)
end

local function defaultFilter(x)
    return true
end

local function filter(observable, criteria)
    return new(_, function (next, err, complete, closed)
        criteria = isFunction(criteria) and criteria or defaultFilter
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                local status, result = pcall(function ()
                    return criteria(x, seq, observable)
                end)

                if(status) then 
                    if(result) then 
                        next(x)
                    end 
                else 
                    err(result)
                end
            end,
            err,
            complete
        )
    end)
end

local function first(observable, criteria)
    return new(_, function (next, err, complete, closed)
        criteria = isFunction(criteria) and criteria or defaultFilter

        local found = false
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                local status, result = pcall(function ()
                    return criteria(x, seq, observable)
                end)

                if(status) then 
                    if(result) then 
                        next(x)
                        complete()

                        found = true
                    end 
                else 
                    err(result)
                end
            end,
            err,
            function ()
                if(found) then 
                    complete()
                else 
                    err("Sequence contains no elements.")
                end
            end
        )
    end)
end

local function single(observable, criteria)
    return new(_, function (next, err, complete, closed)
        local foundValue = nil
        local moreOccurence = false
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                local status, result = pcall(function ()
                    return criteria(x, seq, observable)
                end) 
                
                if(status) then 
                    if(result) then 
                        if(foundValue) then 
                            moreOccurence = true 
                        else 
                            foundValue = x
                        end 
                    end 
                else 
                    err(result)
                end
            end,
            err,
            function ()
                if(foundValue and not moreOccurence) then 
                    next(foundValue)
                    complete()
                else 
                    err("Sequence contains no elements.")
                end 
            end
        )
    end)
end

local function find(observable, criteria)
    return new(_, function (next, err, complete, closed)
        criteria = isFunction(criteria) and criteria or defaultFilter

        local found = false
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                local status, result = pcall(function ()
                    return criteria(x, seq, observable)
                end)

                if(status) then 
                    if(result) then 
                        next(x)
                        complete()

                        found = true
                    end 
                else 
                    err(result)
                end
            end,
            err,
            function ()
                if(not found) then 
                    next(nil)
                end
                complete()
            end
        )
    end)
end

local function ignore(observable)
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            nil,
            err,
            complete
        )
    end)
end

local function last(observable, predicate, last)
    return new(_, function (next, err, complete, closed)
        predicate = predicate or defaultFilter
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1 

                local status, result = pcall(function ()
                    return predicate(x, seq, observable)
                end)

                if(result) then 
                    last = x
                end
            end,
            err,
            function ()
                if(seq == 0 or not last) then 
                    err("Sequence contains no elements.")
                else 
                    next(last)
                    complete()
                end 
            end
        )
    end)
end

local function skip(observable, amount)
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            function (x)
                if(amount == 0) then 
                    next(x)
                else
                    amount = amount - 1
                end
            end, 
            err, 
            complete
        )
    end)
end

local function skipLast(observable, amount)
    return new(_, function (next, err, complete, closed)
        local emissions = {}
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                emissions[seq] = x 

                if(seq > amount) then 
                    next(emissions[seq - amount])
                end 
            end,
            err,
            complete
        )
    end)
end

local function skipUntil(observable, emitter)
    return new(_, function (next, err, complete, closed)
        local beginEmission = false 

        subscribe(observable,
            function (x)
                if(beginEmission) then 
                    next(x)
                end
            end,
            err,
            complete
        )

        subscribe(emitter,
            function (x)
                beginEmission = true 
            end,
            err,
            complete
        )
    end)
end

local function skipWhile(observable, criteria)
    return new(_, function (next, err, complete, closed)
        criteria = isFunction(criteria) and criteria or defaultFilter
        local beginEmission = false
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                local status, result = pcall(function ()
                    return criteria(x, seq, observable)
                end)

                if(status) then 
                    if(not (result or beginEmission)) then 
                        beginEmission = true
                    end 

                    if(beginEmission) then 
                        next(x)
                    end 
                end 
            end,
            err,
            complete
        )
    end)
end

local function take(observable, amount)
    return new(_, function (next, err, complete, closed)
        local counter = 0

        subscribe(observable,
            function (x)
                counter = counter + 1
                if(counter <= amount) then 
                    next(x)
                else 
                    complete()
                end 
            end,
            err,
            complete
        )
    end)
end 

local function takeLast(observable, amount)
    return new(_, function (next, err, complete, closed)
        local emissions = {}
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                emissions[seq] = x 
            end,
            err,
            function ()
                if(seq >= amount) then 
                    for i = seq - amount + 1, seq do 
                        next(emissions[i])
                    end 
                end
                complete()
            end
        )
    end)
end

local function takeUntil(observable, emitter)
    return new(_, function (next, err, complete, closed)
        local endEmission = false
        subscribe(observable,
            function (x)
                if(endEmission) then 
                    complete()
                else 
                    next(x)
                end 
            end,
            err,
            complete
        )

        subscribe(emitter,
            function (x)
                endEmission = true 
                complete()
            end,
            err,
            complete
        )
    end)
end

local function takeLastBuffer(observable, amount)
    return new(_, function (next, err, complete, closed)
        local emissions = {}
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                emissions[seq] = x 
            end,
            err,
            function ()
                if(seq >= amount) then 
                    local acc = {}
                    local c = 0
                    for i = seq - amount + 1, seq do 
                        c = c + 1
                        acc[c] = emissions[i]
                    end 
                    next(acc)
                end
                complete()
            end
        )
    end)
end

local function takeWhile(observable, criteria)
    return new(_, function (next, err, complete, closed)
        criteria = isFunction(criteria) and criteria or defaultFilter
        local endEmission = false 
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                if(endEmission) then 
                    complete()
                else 
                    local status, result = pcall(function ()
                        return criteria(x, seq, observable)
                    end)

                    if(status) then
                        if(result) then 
                            next(x)
                        else 
                            endEmission = true 
                            complete()
                        end 
                    else 
                        err(result)
                    end 
                end
            end,
            err,
            complete
        )
    end)
end

--[[
    Combining Observables
]]

local function defaultCombinator(...)
    return {...} 
end

local function combineLatest(observable, emitter, combinator)
    return new(_, function (next, err, complete, closed)
        combinator = isFunction(combinator) and combinator or defaultCombinator

        local emissionReadyA = false
        local emissionReadyB = false
        local lastValueA = nil
        local lastValueB = nil

        local endA = false 
        local endB = false 

        subscribe(observable,
            function (x)
                lastValueA = x 
                emissionReadyA = true 
                if(emissionReadyB) then 
                    local status, result = pcall(function ()
                        return combinator(lastValueA, lastValueB)
                    end)

                    if(status) then 
                        next(result)
                    else 
                        err(result)
                    end 
                end 
            end,
            err, 
            function ()
                endA = true 
                if(endB) then 
                    complete()
                end
            end 
        )

        subscribe(emitter,
            function (x)
                lastValueB = x 
                emissionReadyB = true 
                if(emissionReadyA) then 
                    local status, result = pcall(function ()
                        return combinator(lastValueA, lastValueB)
                    end)

                    if(status) then 
                        next(result)
                    else 
                        err(result)
                    end 
                end 
            end,
            err, 
            function ()
                endB = true 
                if(endA) then 
                    complete()
                end
            end 
        )
    end)
end 

local function withLatestFrom(observable, emitter, combinator)
    return new(_, function (next, err, complete, closed)
        combinator = isFunction(combinator) and combinator or defaultCombinator

        local emissionReadyA = false
        local emissionReadyB = false
        local lastValueA = nil
        local lastValueB = nil

        local endA = false 
        local endB = false 

        subscribe(observable,
            function (x)
                lastValueA = x 
                emissionReadyA = true 
                if(emissionReadyB) then 
                    local status, result = pcall(function ()
                        return combinator(lastValueA, lastValueB)
                    end)

                    if(status) then 
                        next(result)
                    else 
                        err(result)
                    end 
                end 
            end,
            err, 
            function ()
                endA = true 
                if(endB) then 
                    complete()
                end
            end 
        )

        subscribe(emitter,
            function (x)
                lastValueB = x 
                emissionReadyB = true 
            end,
            err, 
            function ()
                endB = true 
                if(endA) then 
                    complete()
                end
            end 
        )
    end)
end

local function merge(observable, ...)
    local observables = {...}
    local count = #observables
    return new(_, function (next, err, complete, closed)
        observables[0] = observable

        for i = 0, count do 
            subscribe(observables[i], 
                next,
                err, 
                function ()
                    count = count - 1
                    if(count == -1) then 
                        complete()
                    end
                end 
            )
        end 
    end)
end 

local function startWith(observable, ...)
    local values = {...}
    
    return new(_, function (next, err, complete, closed)
        for i = 1, #values do 
            next(values[i])
        end 
        subscribe(observable,
            next,
            err,
            complete
        )
    end)
end 

local function zip(...)
    local observables = {...}
    local count = #observables
    local combinator = observables[count]

    if(isFunction(combinator)) then 
        count = count - 1
    else 
        combinator = defaultCombinator
    end 


    return new(_, function (next, err, complete, closed)
        local lastValue = {}
        local flags = {}
        local ready = count

        for i = 1, count do 
            subscribe(observables[i],
                function (x)
                    lastValue[i] = x 
                    if(ready == 0) then 
                        local status, result = pcall(function ()
                            return combinator(unpack(lastValue))
                        end)

                        if(status) then 
                            next(result)
                            ready = count
                            flags = {}
                        else 
                            err(result)
                        end 
                    elseif(not flags[i]) then
                        ready = ready - 1
                        flags[i] = true
                    end 
                end, 
                err,
                complete
            )
        end 
    end)
end 


local function staticForkJoin(...)
    local observables = {...}

    return new(_, function (next, err, complete, closed)
        local values = {}
        local ready = #observables
        for k, obs in ipairs(observables) do 
            subscribe(obs,
                function (x)
                    values[k] = x 
                end,
                err,
                function ()
                    ready = ready - 1
                    if(ready == 0) then 
                        next(values)
                        complete()
                    end 
                end 
            )
        end 
    end)
end

local function forkJoin(observable, emitter, combinator)
    combinator = isFunction(combinator) and combinator or defaultCombinator
    return new(_, function (next, err, complete, closed)
        local lastValueA = nil
        local lastValueB = nil

        local readyA = false
        local readyB = false 

        subscribe(observable,
            function (x)
                lastValueA = x
                readyA = true 
            end,
            err, 
            function ()
                if(readyB) then 
                    local status, result = pcall(function ()
                        return combinator(lastValueA, lastValueB)
                    end)
                    
                    if(status) then 
                        next(result)
                        complete()
                    end 
                end 
            end 
        )

        subscribe(emitter,
            function (x)
                lastValueB = x 
                readyB = true 
            end,
            err, 
            function ()
                if(readyA) then 
                    local status, result = pcall(function ()
                        return combinator(lastValueA, lastValueB)
                    end)
                    
                    if(status) then 
                        next(result)
                        complete()
                    end 
                end 
            end
        )
    end)
end 

--[[
    Error Handling
]]

local function catch(observable, handler)
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            next,
            function (...)
                local args = {...}
                if(isFunction(handler)) then 
                    local status, result = pcall(function ()
                        return handler(unpack(args))
                    end)

                    if(status) then 
                        if(isObservable(result)) then 
                            subscribe(result,
                                next,
                                err,
                                complete
                            )
                        else 
                            next(result)
                        end 
                    else 
                        err(result)
                    end 
                else 
                    subscribe(handler,
                        next,
                        err,
                        complete
                    )
                end 
            end,
            complete
        )
    end)
end 

local function onErrorResumeNext(observable, handler)
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            next,
            function (...)
                local args = {...}
                if(isFunction(handler)) then 
                    local status, result = pcall(function ()
                        return handler(unpack(args))
                    end)

                    if(status) then 
                        if(isObservable(result)) then 
                            subscribe(result,
                                next,
                                err,
                                complete
                            )
                        else 
                            next(result)
                        end 
                    else 
                        err(result)
                    end 
                else 
                    subscribe(handler,
                        next,
                        err,
                        complete
                    )
                end 
            end,
            function (...)
                local args = {...}
                if(isFunction(handler)) then 
                    local status, result = pcall(function ()
                        return handler(unpack(args))
                    end)

                    if(status) then 
                        if(isObservable(result)) then 
                            subscribe(result,
                                next,
                                err,
                                complete
                            )
                        else 
                            next(result)
                        end 
                    else 
                        err(result)
                    end 
                else 
                    subscribe(handler,
                        next,
                        err,
                        complete
                    )
                end 
            end
        )
    end)
end

--[[
    Utility
]]

local function tap(observable, onNext, onError, onComplete)
    onNext = isFunction(onNext) and onNext or emptyHandler
    onError = isFunction(onError) and onError or emptyHandler
    onComplete = isFunction(onComplete) and onComplete or emptyHandler

    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            function(...)
                onNext(...)
                next(...)
            end,
            function(...)
                onError(...)
                err(...)
            end,
            function()
                onComplete()
                complete()
            end
        )
    end)
end 

local function tapOnNext(observable, onNext)
    onNext = isFunction(onNext) and onNext or emptyHandler
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            function(...)
                onNext(...)
                next(...)
            end,
            err,
            complete
        )
    end)
end

local function tapOnError(observable, onError)
    onError = isFunction(onError) and onError or emptyHandler
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            next,
            function(...)
                onError(...)
                err(...)
            end,
            complete
        )
    end)
end

local function tapOnComplete(observable, onComplete)
    onComplete = isFunction(onComplete) and onComplete or emptyHandler
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            next,
            err,
            function()
                onComplete()
                complete()
            end
        )
    end)
end

local function finally(observable, final)
    final = isFunction(final) and final or emptyHandler
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            next,
            function (...)
                final(...)
                err(...)
            end,
            function ()
                final()
                complete()
            end
        )
    end)
end
--[[
    Conditional and Boolean
]]

local function all(observable, criteria)
    criteria = isFunction(criteria) and criteria or defaultFilter

    return new(_, function (next, error, complete, closed)
        subscribe(observable,
            function (x)
                local status, result = pcall(function ()
                    return criteria(x)
                end)

                if(status) then 
                    if(not result) then 
                        next(false)
                        complete()
                    end 
                else 
                    err(result)
                end 
            end,
            err,
            function ()
                next(true)
                complete()
            end 
        )
    end)
end 

local function defaultSortingComparator(a, b)
    return b - a
end 


local function sorted(observable, comparator)
    comparator = isFunction(comparator) and comparator or defaultSortingComparator
    return new(_, function (next, err, complete, closed)
        local prev
        subscribe(observable,
            function (x)
                if(prev) then 
                    local status, result = pcall(function ()
                        return comparator(prev, x)
                    end)

                    if(status) then 
                        if(result < 0) then 
                            next(false)
                            complete()
                        end 
                    else 
                        err(result)
                    end
                end 
                prev = x
            end,
            err,
            function ()
                next(true)
                complete()
            end)
    end)
end 

local function amb(...)
    local observables = {...}

    return new(_, function (next, err, complete, closed)
        local first 
        for k, observable in ipairs(observables) do 
            subscribe(observable,
                function (...)
                    if(not first) then 
                        first = observable
                    end 

                    if(observable == first) then 
                        next(...)
                    end     
                end,
                function (...)
                    if(not first) then 
                        first = observable
                    end 

                    if(observable == first) then 
                        err(...)
                    end     
                end,
                function ()
                    if(not first) then 
                        first = observable
                    end 

                    if(observable == first) then 
                        complete()
                    end     
                end
            )
        end 
    end)
end 

local function contains(observable, value)
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            function (x)
                if(x == value) then 
                    next(true)
                    complete()
                end 
            end,
            err,
            function ()
                next(false)
                complete()
            end
        )
    end)
end

local function indexOf(observable, value, start)
    start = 0
    return new(_, function (next, err, complete, closed)
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                if(start == 0) then 
                    if(x == value) then 
                        next(seq)
                        complete()
                    end 
                else 
                    start = start - 1
                end
            end,
            err,
            function ()
                next(-1)
                complete()
            end
        )
    end)
end

local function findIndex(observable, handler)
    handler = isFunction(handler) and handler or defaultFilter
    return new(_, function (next, err, complete, closed)
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
                if(start == 0) then 
                    local status, result = pcall(function ()
                        return handler(x)
                    end)
                    if(status) then 
                        if(result) then 
                            next(seq)
                            complete()
                        end 
                    else 
                        err(result)
                    end 
                else 
                    start = start - 1
                end
            end,
            err,
            function ()
                next(-1)
                complete()
            end
        )
    end)
end 

local function isEmpty(observable)
    return new(_, function (next, err, complete, closed)
        subscribe(observable,
            function (x)
                next(false)
                complete()
            end,
            err,
            function ()
                next(true)
                complete()
            end 
        )
    end)
end 

local function defaultIfEmpty(observable, def)
    return new(_, function (next, err, complete, closed)
        local notEmpty = false 
        subscribe(observable,
            function (x)
                next(x)
                notEmpty = true
            end,
            err,
            function ()
                if(notEmpty) then 
                    next(def)
                end
                complete()
            end 
        )
    end)
end

--[[
    Aggregates
]]
local function average(observable)
    return new(_, function (next, err, complete, closed)
        local acc = 0
        local seq = 0
        subscribe(observable,
            function (x)
                acc = acc + x 
                seq = seq + 1
            end,
            err,
            function ()
                if(seq == 0) then 
                    next(0)
                else 
                    next(acc/seq)
                end
                complete()
            end
        )
    end)
end 

local function count(observable)
    return new(_, function (next, err, complete, closed)
        local seq = 0
        subscribe(observable,
            function (x)
                seq = seq + 1
            end,
            err,
            function ()
                next(seq)
                complete()
            end
        )
    end)
end

local function max(observable)
    return new(_, function (next, err, complete, closed)
        local maxValue = 0
        subscribe(observable,
            function (x)
                if(x > maxValue) then 
                    maxValue = x 
                end
            end,
            err,
            function ()
                next(maxValue)
                complete()
            end
        )
    end)
end 

local function min(observable)
    return new(_, function (next, err, complete, closed)
        local minValue = 2^32
        subscribe(observable,
            function (x)
                if(x < minValue) then 
                    minValue = x 
                end
            end,
            err,
            function ()
                next(minValue)
                complete()
            end
        )
    end)
end 

local function sum(observable)
    return new(_, function (next, err, complete, closed)
        local acc = 0
        subscribe(observable,
            function (x)
                acc = acc + x 
            end,
            err,
            function ()
                next(acc)
                complete()
            end
        )
    end)
end 

local function defaultReductor(x)
    return x 
end

local function reduce(observable, reductor)
    return new(_, function (next, err, complete, closed)
        local acc
        subscribe(observable,
            function (x)
                local status, result = pcall(function ()
                    return reductor(acc or 0, x)
                end)

                if(status) then 
                    acc = result 
                else 
                    err(result)
                end
            end,
            err,
            function ()
                next(acc)
                complete()
            end
        )
    end)
end 

local Observable = setmetatable({}, M)

Observable.from = from 
Observable.of = of 

Observable.empty = empty 
Observable.never = never 
Observable.throw = throw 
Observable.just = just 
Observable.range = range 
Observable.doRepeat = doRepeat

Observable.zip = zip
Observable.forkJoin = staticForkJoin

Observable.amb = amb

M.__call = new
M.__index = {
    subscribe = subscribe,

    doWhile= doWhile,

    buffer = buffer,
    map = map,
    pluck = pluck,
    scan = scan,
    flatMap = flatMap,
    flatMapLatest = flatMapLatest,

    distinct = distinct,
    distinctUntilChanged = distinctUntilChanged,
    elementAt = elementAt,
    filter = filter,
    first = first,
    single = single,
    find = find,
    ignore = ignore,
    last = last,
    skip = skip,
    skipLast = skipLast,
    skipUntil = skipUntil,
    skipWhile = skipWhile,
    take = take,
    takeLast = takeLast,
    takeUntil = takeUntil,
    takeLastBuffer = takeLastBuffer,
    takeWhile = takeWhile,

    combineLatest = combineLatest,
    withLatestFrom = withLatestFrom,
    merge = merge,
    startWith = startWith,
    forkJoin = forkJoin,

    tap = tap,
    tapOnNext = tapOnNext,
    tapOnError = tapOnError,
    tapOnComplete = tapOnComplete,
    finally = finally,
    

    catch = catch,
    onErrorResumeNext = onErrorResumeNext,

    all = all,
    sorted = sorted,
    contains = contains,
    indexOf = indexOf,
    findIndex = findIndex,
    isEmpty = isEmpty,
    defaultIfEmpty = defaultIfEmpty,

    average = average,
    min = min,
    max = max,
    count = count,
    reduce,
}

return Observable